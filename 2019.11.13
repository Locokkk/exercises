//不要二
//有一个W*H的网格盒子，网格的行编号为0~H-1，网格的列编号为0~W-1。每个格子至多能放一块蛋糕，任意两块蛋糕的欧几里得距离不能等于2。
//对于两个格子坐标(x1,y1),(x2,y2)的欧几里得距离为:
//( (x1-x2) * (x1-x2) + (y1-y2) * (y1-y2) ) 的算术平方根
//最多可以放多少块蛋糕在网格盒子里?
//输入：每组数组包含网格长宽W,H，用空格分割.(1 ≤ W、H ≤ 1000)
//输出：网格盒子最多可以放的蛋糕数

////解题思路：定义一个数组a[1000][1000],初始值都为0，从a[0][0]开始,将a[0][2]和a[2][0]置为-1（相对位置）,遍历数组，不是-1的地方可以放蛋糕。

#include<iostream>
using namespace std;
int main()
{
    int arr[1000][1000]={0};
    int W,H,ret=0;
    cin>>W>>H;
    for(int i=0;i<W;i++)
    {
        for(int j=0;j<H;j++)
        {
            if(arr[i][j]==0)
            {
                ret++;
                if(i+2<W) arr[i+2][j]=-1;//相对位置置为-1
                if(j+2<H) arr[i][j+2]=-1;
            }
        }
    }
    cout<<ret<<endl;
    return 0;
}



//把字符型转换成整数
//将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0
//输入：输入一个字符串,包括数字字母符号,可以为空    输出：如果是合法的数值表达则返回该数字，否则返回0

class Solution {
public:
    int StrToInt(string str)
    {
        int flag=1;
        int sum=0;
        if(str.empty())
        {//判空
            return 0;
        }
        if(str[0]=='-')
        {//处理负号
            flag=-1;
            str[0]='0';
        }
         if(str[0]=='+')
        {//处理正号
            flag=1;
            str[0]='0';
        }
        
        for(size_t i=0;i<str.size();i++)
        {
            if(str[i]<'0'||str[i]>'9')//不是合法数值的处理
            {
                sum=0;
                break;
            }
            sum=sum*10+str[i]-'0';//对合法的字符型数字的处理，字符型转数字型再一位一位地计算数值
        }
        return sum*flag;
    }
};





